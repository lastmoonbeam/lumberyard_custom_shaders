/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/
// Original file Copyright Crytek GMBH or its affiliates, used under license.

#define VS_NO_SKINNING_DATA

// dx11 obfuscated this quite further, clean up for refactor phase

#include "Common.cfi"
#include "ModificatorVT.cfi"
#include "ShadeLib.cfi"
#include "PostEffectsLib.cfi"

float Script : STANDARDSGLOBAL
<
    string Script =
        "Public;"
        "NoPreview;"
        "ShaderDrawType = General;"
        "ShaderType = Water;"
        "PreprType = ScanWater;"

#if %WATER_TESSELLATION_DX11
        "HWTessellation;"
#endif
>;

/// Un-Tweakables

float4x4 mViewProjI : PB_UnProjMatrix;

// getting a warning here
float4x4 mReflProj : PI_TexMatrix
<
    string 'Sampler' (ReflectionSampler)
>;

// water waves parameters
float4 OceanParams0 = { PB_FromRE[0], PB_FromRE[1], PB_FromRE[2], PB_FromRE[3] };
float4 OceanParams1 = { PB_FromRE[4], PB_FromRE[5], PB_FromRE[6], PB_FromRE[7] };

// Fog parameters
// For ocean comes from render element
float4 cFogColorDensity = { PB_FromRE[8], PB_FromRE[9], PB_FromRE[10], PB_FromRE[11] };

// Tweakables

float SoftIntersectionFactor
<
  register = PER_MATERIAL_1.x;
  string UIName = "Soft intersection factor";
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 10.0;
  float UIStep = 0.1;
> = 1.0;

float Tilling // @TODO: Fix spelling when versioning is supported on material settings.
<
    register = PER_MATERIAL_1.z;
    string UIHelp = "Set bump tiling";
    string UIName = "Tiling";

    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 32.0;
    float UIStep = 0.001;
> = 10.0;

float DetailTilling // @TODO: Fix spelling when versioning is supported on material settings.
<
    register = PER_MATERIAL_1.w;
    string UIHelp = "Set detail bump tiling";
    string UIName = "Detail Tiling";

    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 32.0;
    float UIStep = 0.001;;
> = 2.5;

float RainTilling // @TODO: Fix spelling when versioning is supported on material settings.
<
    register = PER_MATERIAL_2.x;
    string UIName = "Rain ripples tiling";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.001;
> = 1.0;

half FresnelGloss
<
    register = PER_MATERIAL_2.y;
    string UIName = "Fresnel gloss";
    string UIWidget = "slider";
    float UIMin = 0;
    float UIMax = 1.0;
    float UIStep = 0.001;
> = 0.9;

#if %ENVIRONMENT_MAP
half ReflectionScale
<
    register = PER_MATERIAL_2.z;
    string UIWidget = "slider";
    string UIName = "Env map reflection scale";
    float UIMin = 0.0;
    float UIMax = 32.0;
    float UIStep = 0.001;
> = 1.0;
#endif

half SubSurfaceScatteringScale
<
    register = PER_MATERIAL_2.w;
    string UIName = "SSS scale";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 200.0;
    float UIStep = 0.1;
> = 10.0;

half ReflectionBumpScale
<
    register = PER_MATERIAL_3.x;
    string UIWidget = "slider";
    string UIName = "Reflection bump scale";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.001;
> = 0.1;

half RefractionBumpScale
<
    register = PER_MATERIAL_3.y;
    string UIWidget = "slider";
    string UIName = "Refraction bump scale";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.001;
> = 0.1;

half DetailNormalsScale
<
    register = PER_MATERIAL_3.z;
    string UIWidget = "slider";
    string UIName = "Detail Normals scale";
    float UIMin = 0.0;
    float UIMax = 4.0;
    float UIStep = 0.001;
> = 0.5;

half NormalsScale
<
    register = PER_MATERIAL_3.w;
    string UIWidget = "slider";
    string UIName = "Normals scale";
    float UIMin = 0.0;
    float UIMax = 4.0;
    float UIStep = 0.001;
> = 1.25;

half GradientScale
<
    register = PER_MATERIAL_4.x;
    string UIWidget = "slider";
    string UIName = "Gradient scale";
    float UIMin = 0.0;
    float UIMax = 0.15;
    float UIStep = 0.001;
> = 0.1;

half HeightScale
<
    register = PER_MATERIAL_4.y;
    string UIWidget = "slider";
    string UIName = "Height scale";
    float UIMin = 0.0;
    float UIMax = 0.25;
    float UIStep = 0.001;
> = 0.2;

#if %FOAM

half FoamSoftIntersectionFactor
<
    register = PER_MATERIAL_4.z;
    string UIName = "Foam soft intersection";
    string UIWidget = "slider";
    float UIMin = 0.1;
    float UIMax = 10.0;
    float UIStep = 0.1;
> = 0.75;

half FoamAmount
<
    register = PER_MATERIAL_4.w;
    string UIName = "Foam Amount";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 8.0;
    float UIStep = 0.001;
> = 1.0;

half FoamCrestAmount
<
    register = PER_MATERIAL_5.x;
    string UIName = "Crest Foam Amount";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 10.0;
    float UIStep = 0.001;
> = 1.0;

half FoamTilling // @TODO: Fix spelling when versioning is supported on material settings.
<
    register = PER_MATERIAL_5.y;
    string UIName = "Foam tiling";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 32.0;
    float UIStep = 0.001;
> = 12.0;

#endif // %FOAM

//////////////////////////////////////////////////////////////////////////////////////////////////

sampler2D FFTVertexTexSampler : register(s0);
sampler2D WaterDynRipplesVertexTexSampler : register(s1);

sampler2D ReflectionSampler : register(s0)
<
    string Script =
        "RenderOrder=PreProcess;"
        "ProcessOrder=WaterReflection;"
        "RenderCamera=WaterPlaneReflected;"
        "RenderTarget_IDPool = _RT2D_WATER_ID;"
        "RenderTarget_Width=$ScreenSize;"
        "RenderTarget_Height=$ScreenSize;"
        "RenderTarget_UpdateType=WaterReflect;"
        "RenderDepthStencilTarget=DepthBuffer;"
        "ClearSetColor=Black;"
        "ClearSetDepth=1;"
        "ClearTarget=Color;"
        "ClearTarget=Depth;";
>
{
    Texture = $RT_2D;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = NONE;
    AddressU = Clamp;
    AddressV = Clamp;
};

sampler2D RefractionSampler : register(s1)
{
    Texture = $SceneTarget;
    MinFilter = POINT;
    MagFilter = POINT;
    MipFilter = POINT;
    AddressU = Clamp;
    AddressV = Clamp;
    sRGBLookup = true;
};

ENVIRONMENTMAP
ENVIRONMENTCUBEMAP

sampler2D WaterNormalsSampler
{
    // eTF_A8B8G8R8S - eTF_R8G8B8A8 for fixed point
    Texture = $WaterVolumeDDN;

    MinFilter = ANISOTROPIC;
    MagFilter = ANISOTROPIC;
    MipFilter = ANISOTROPIC;
    AnisotropyLevel = 16;

    AddressU = Wrap;
    AddressV = Wrap;
};

#ifdef %ST_FIXED_POINT
    //eTF_R8G8B8A8
    float4 ExpandWaterNormals(float4 waterNormals)
    {
        return EXPAND(waterNormals);
    }
#else
    // eTF_A8B8G8R8S
    float4 ExpandWaterNormals(float4 waterNormals)
    {
        return waterNormals;
    }
#endif

sampler2D FoamSampler
{
    Texture = EngineAssets/Shading/WaterFoam.tif;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;

    sRGBLookup = false;
};

sampler2D WaterGlossMapSampler
{
    Texture = EngineAssets/Textures/water_gloss.dds;
    MinFilter = LINEAR;
    MagFilter = LINEAR;

    // Hack for having noisy/sharp specular highlights. Bad for performance but even with anisotropic filtering it looks too smooth
    MipFilter = LINEAR;

    AddressU = Wrap;
    AddressV = Wrap;

    sRGBLookup = false;
};

sampler2D RainRipplesSampler = sampler_state
{
    // eTF_BC5S
    Texture = Textures/Rain/Ripple/ripple#01_24_ddn.dds;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = POINT;
    AddressU = Wrap;
    AddressV = Wrap;
};

sampler2D WaterDynRipplesSampler = sampler_state
{
    // eTF_A8R8G8B8
    Texture = $WaterRipplesDDN_0;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
    AddressU = Clamp;
    AddressV = Clamp;
};

sampler2D WaterDisplMapSampler = sampler_state
{
    // eTF_A32B32G32R32F
    Texture = $WaterOceanMap;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = POINT;
    AddressU = Wrap;
    AddressV = Wrap;
};

//////////////////////////////////////////////////////////////////////////////////////////////////

struct a2v
{
    float4 Position : POSITION;

    float2 baseTC   : TEXCOORD;
    float4 Color    : COLOR;
};

struct v2f
{
#if !%WATER_TESSELLATION_DX11
    float4 Position     : POSITION;
#endif

    float4 baseTC       : TEXCOORDN;
    float4 screenProj   : TEXCOORDN;
    float4 envTC        : TEXCOORDN;
    float4  vView        : TEXCOORDN;

    half4 GlossinessK   : TEXCOORDN;
    half4 cSpecular     : TEXCOORDN;

    float4 vPosWS       : TEXCOORDN;

#if %_RT_SAMPLE4
    float4 ripplesTC    : TEXCOORDN;
#endif

    half4 vVertexNormal : TEXCOORDN;
#if %WATER_TESSELLATION_DX11
    float4 vOceanParams : TEXCOORDN;
#endif
};

struct v2f_hs
{
    float4 Position     : POSITION;
    float4 baseTC       : TEXCOORDN;
    float4 screenProj   : TEXCOORDN;
    float4 envTC        : TEXCOORDN;
    float4  vView        : TEXCOORDN;

    half4 GlossinessK   : TEXCOORDN;
    half4 cSpecular     : TEXCOORDN;

    float4 vPosWS       : TEXCOORDN;

#if %_RT_SAMPLE4
    float4 ripplesTC    : TEXCOORDN;
#endif

    half4 vVertexNormal : TEXCOORDN;
#if %WATER_TESSELLATION_DX11
    float4 vOceanParams : TEXCOORDN;
#endif
};

//////////////////////////////////////////////////////////////////////////////////////////////////
// DX11 specifics

struct HS_CONSTANT_DATA_OUTPUT
{
    float Edges[3] : SV_TessFactor;
    float Inside   : SV_InsideTessFactor;
};

struct HS_CONTROL_POINT_OUTPUT
{
    float4 baseTC       : TEXCOORDN;
    float4 screenProj   : TEXCOORDN;
    float4 envTC        : TEXCOORDN;
    half4  vView        : TEXCOORDN;

    half4 GlossinessK   : TEXCOORDN;
    half4 cSpecular     : TEXCOORDN;

    float4 vPosWS       : TEXCOORDN;

#if %_RT_SAMPLE4
    float4 ripplesTC    : TEXCOORDN;
#endif

    half4 vVertexNormal : TEXCOORDN;
    float4 vOceanParams : TEXCOORDN;

};

//////////////////////////////////////////////////////////////////////////////////////////////////
// Bilinear filtered texture read

float4 tex2DlodBilinear(in sampler2D s, in float2 t, in float2 textureSize, in float2 texelSize)
{
    float2 f = frac(t * textureSize);

    // TODO: take advantage of arbitrary swizzles for 2.x & 3.0
    float4 t00 = tex2Dlod(s,  float4(t, 0.0, 0.0));
    float4 t10 = tex2Dlod(s, float4(t + float2(texelSize.x, 0.0), 0.0, 0.0));
    float4 tA = lerp(t00, t10, f.x);

    float4 t01 = tex2Dlod(s, float4(t + float2(0.0, texelSize.y), 0.0, 0.0));
    float4 t11 = tex2Dlod(s, float4(t + float2(texelSize.x, texelSize.y), 0.0, 0.0));
    float4 tB = lerp(t01, t11, f.x);

    return lerp(tA, tB, f.y);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Get vertex from screen space into world space

void GetGridVertexPos(inout float4 vPos)
{
#if %WATER_TESSELLATION_DX11

    // lower than hi spec uses low tesselated screen space grid and no vertex displacement
    float4 vPosOrig = vPos;
    vPos.xy = (vPos.xy * 2.0 - 1.0) * ((vPos.w > 0.98)?PerView_NearFarClipDist.y * 2.0 : 500.0);

    // snap grid to avoid translation aliasing - this can be improved..
    float2 cpos = PerView_WorldViewPos.xy;

    // ATI specific fix - skip using frac togheter with big values, breaks somehow. Alternatively better compute this on cpu
    cpos.xy -= frac(cpos.xy / OceanParams0.x) * OceanParams0.x;

    vPos.xy += cpos;//PerView_WorldViewPos.xy;

    // set ocean level and add offset to hide precision artifact at horizon
    vPos.z = OceanParams1.w + (4.5f * (vPos.w > 0.98f));

    return;
#endif

    if(GetShaderQuality() >= QUALITY_HIGH)
    {
        // hi specs uses regular tessellated grid plus vertex displacement

        float atten = vPos.z;

        // simple lod - keep nearby detail until 200 meters after that project all vertices to horizon
        float fLod0 = 100.0 * (1.0 / min(OceanParams0.w, 2.0));

        // Set a 45 degree rotation to the grid
        vPos.xy = 0.707 * vPos.xy + 0.707 * float2(-vPos.y, vPos.x);

        float3x3 mCam = float3x3(PerView_ViewBasisX.xyz, PerView_ViewBasisY.xyz, PerView_ViewBasisZ.xyz);

        // select better projection axis if front angle too steep
        const float fFrontThreshold = 0.75;
        float fFrontDotUpAxis = abs(PerView_ViewBasisZ.z);
        if(fFrontDotUpAxis > fFrontThreshold)
        {
            mCam[1] = PerView_ViewBasisZ;
            mCam[2] = -PerView_ViewBasisY;
        }

        mCam = transpose(mCam);

        // Orientate along camera direction - try keeping good amount of triangles on screen
        float3 vPosRot = (mul(((const float3x3) mCam), -fLod0 * float3(vPos.x, 0, vPos.y - 0.3)));

        // snap grid to avoid translation aliasing - this can be improved..
        float2 cpos = PerView_WorldViewPos.xy;

        // ATI specific fix - skip using frac together with big values, breaks somehow. Alternatively better compute this on cpu
        cpos.xy -= (atten <0.98)?frac(cpos.xy / 10.0) * 10.0 : 0.0;

        float fDistCamera = length(vPosRot.xy);
        fDistCamera *= fDistCamera * 0.085;

        //ATI specific fix - stretch the grid according to the direction, mainly the nearer half so that the border cells are always outside the screen
        float t = dot(normalize(PerView_ViewBasisZ.xy), normalize(vPosRot.xy));
        fDistCamera *= 1.0 + (t + 1.0) * (t + 1.0) * abs(PerView_WorldViewPos.z - OceanParams1.w) / 16.0; //stretch grid according to camera height so that the projected grid

        // snap edges in front of camera to horizon - multiply FarDist by 2.0 to remove unnecessary gaps btwn ocean and sky.
        fDistCamera = (sign(-t) * atten > 0.98) ? PerView_NearFarClipDist.y * 2.0 : fDistCamera;

        // ATI specific fix - clamp values to reasonable range
        fDistCamera = min(16384.0f, fDistCamera);

        // add offset to ocean level to hide precision artifact at horizon
        float fLevelOffset = (4.5f * (atten > 0.98f));

        vPos = float4(cpos.xy + normalize(vPosRot.xy) * fDistCamera, OceanParams1.w + fLevelOffset, 1.0);
    }
    else
    {
        // lower than hi spec uses low tessellated screen space grid and no vertex displacement

        const float fGridQuadSize = 1.0 / 10.0;
        vPos.xy = vPos.xy * 2.0 - 1.0;
        vPos.xy *= 1.0 + fGridQuadSize * 0.5;
        vPos.zw = float2(0.0, 1.0);

#if %_RT_REVERSE_DEPTH
        vPos.z = vPos.w - vPos.z;
#endif

        float4 vPosWS = mul(mViewProjI, vPos);
        vPosWS /= vPosWS.w;

        // invert sign when bellow water
        float fDirSign = sign(PerView_WorldViewPos.z - OceanParams1.w);

        // get z plane intersections
        float2 z_isecs = fDirSign * float2(PerView_WorldViewPos.zz - float2(vPosWS.z, OceanParams1.w));
        z_isecs.x = max(z_isecs, PerView_NearFarClipDist.w);

        float t = z_isecs.y / z_isecs.x;

        // project vertex along ray direction
        float2 vRayDir = (vPosWS.xy - PerView_WorldViewPos.xy);
        vPos.xy = PerView_WorldViewPos.xy + vRayDir.xy * t;

        // Output ocean level and try avoid precision artefacts at horizon line by adding an offset
        vPos.z = OceanParams1.w + (t / PerView_NearFarClipDist.y);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Map water ripples from world to uv space
float4 WaterRipplesLookupParams : PB_WaterRipplesLookupParams;

float4 GetWaterRipplesUvs(inout float4 vPos)
{
    const float fadeStrength = 0.1;

    float4 tcWaterRipples = 1.0;
    tcWaterRipples.xy = vPos.xy * WaterRipplesLookupParams.x + WaterRipplesLookupParams.zw;

    float2 dist = abs(vPos.xy - PerView_WorldViewPos.xy);
    float2 strength = saturate((WaterRipplesLookupParams.y - dist) * fadeStrength);
    tcWaterRipples.w = min(strength.x, strength.y);

    return tcWaterRipples;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Apply vertex dynamic displacement - additional ocean eye candy for hispecs

void ApplyVertexDisplacement(inout float4 vPos, inout v2f OUT)
{
#if !%_RT_QUALITY && %_RT_QUALITY1
    // Apply FFT vertex displacement

    float2 tcFFT = (vPos.xy) * 0.0125 * OceanParams0.w * 1.25;
    float4 vtxDispl = tex2Dlod(FFTVertexTexSampler, float4(tcFFT, 0.0, 0.0));

    float fCamDist = length(vPos.xyz - PerView_WorldViewPos.xyz);
    float fDisplaceAtten = saturate(fCamDist * 0.5);
    fDisplaceAtten *= fDisplaceAtten;

    vPos.xyz += fDisplaceAtten * vtxDispl.xyz * 0.06 * OceanParams1.x * float3(1.5, 1.5, 1.0);

    // Compute normal on the fly (todo: prebake this in texture alpha..)
    float4 h0 =  vtxDispl;
    float4 h10 = tex2Dlod(FFTVertexTexSampler, float4(tcFFT + float2(1.0 / 64.0, 0.0), 0.0, 0.0));
    float4 h11 = tex2Dlod(FFTVertexTexSampler, float4(tcFFT + float2(0.0, 1.0 / 64.0), 0.0, 0.0));
    half3 vWeights = half3(h0.z, h10.z, h11.z);
    half3 vNormal = half3((vWeights.x - vWeights.y), (vWeights.x - vWeights.z), 8);
    vNormal = normalize(vNormal.xyz);
    OUT.vVertexNormal.xyz = vNormal;
#endif

    // Apply dynamic ripples displacement

#if %_RT_SAMPLE4
    OUT.ripplesTC = GetWaterRipplesUvs(vPos);

    #if !%_RT_QUALITY && %_RT_QUALITY1
        vtxDispl = tex2Dlod(WaterDynRipplesVertexTexSampler, float4(OUT.ripplesTC.xy, 0.0, 0.0));
        vPos.z -= (vtxDispl.z) * OUT.ripplesTC.w;
    #endif
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////

v2f WaterVS(a2v IN)
{
    v2f OUT = (v2f)1.0;
    float4 vPos = IN.Position;
    vPos.w = vPos.z; // store edge information

    // Prepare mesh position
    GetGridVertexPos(vPos);

    const bool bCameraRelative = false;
    float4x4 InstMatrix = GetInstance_WorldMatrix(bCameraRelative);
    vPos.xyz = mul(InstMatrix, float4(vPos.xyz, 1.0));

    float4 vPosOrig = vPos;

#if !%WATER_TESSELLATION_DX11
    // Apply FFT and dynamic water interaction
    ApplyVertexDisplacement(vPos, OUT);

    OUT.Position = mul(PerView_ViewProjMatr, float4(vPos.xyz, 1.0));
#endif

    // Output projected reflection texture coordinates
    float4 vProjTex = mul(mReflProj, float4(vPos.xyz, 1.0));
    OUT.envTC = vProjTex;

    // Output eye/light vector
    float3 vView = PerView_WorldViewPos.xyz - vPos.xyz;

    OUT.vView.xyz = vView.xyz;
    OUT.vView.w = sign(OUT.vView.z);

    // Output projected refraction texture coordinates
#if !%WATER_TESSELLATION_DX11
    // Avoid near clipping
    const float nearClipDistance = 2.0;
    if(dot(OUT.vView.xyz, OUT.vView.xyz) < nearClipDistance * nearClipDistance)
    {
#if %_RT_REVERSE_DEPTH
        OUT.Position.z = (abs(vView.z) > 0.2) ? OUT.Position.z : OUT.Position.w;
#else
        OUT.Position.z *= saturate(abs(vView.z) > 0.2);
#endif
    }

    OUT.screenProj.xyw = HPosToScreenTC(OUT.Position).xyw;
#endif

    // Output refraction depth scale
    OUT.screenProj.z = saturate(1.0 - 0.15 * sqrt(saturate(OUT.screenProj.w)));

#if !%_RT_QUALITY && %_RT_QUALITY1
    float fNormalsAttenuation = saturate(1.0 - 0.01 * OUT.screenProj.w);
    OUT.vVertexNormal.xyz = lerp(float3(0.0, 0.0, 1.0), OUT.vVertexNormal.xyz, fNormalsAttenuation);
#endif

    // Output pre-computed phong normalization (saves 0.4ms on fragment shader)
    OUT.GlossinessK.x = 4.0 * GlossToSpecExp255(PerMaterial_SpecularColor.w);
    OUT.GlossinessK.y = 0.5 * GlossToSpecExp255(PerMaterial_SpecularColor.w);
    OUT.GlossinessK.z = OUT.GlossinessK.x * ONE_OVER_TWO_PI + ONE_OVER_PI;
    OUT.GlossinessK.w = OUT.GlossinessK.y * ONE_OVER_TWO_PI + ONE_OVER_PI;

    OUT.cSpecular.xyz = PerMaterial_SpecularColor * PerFrame_SunColor.xyz * PerFrame_SunColor.w; // also take sun specular into account

    // dont touch this scales
    float2 vTex = vPos.xy * 0.005;

    // Output texture coordinates for water - don't touch texture scales
    OUT.baseTC.xywz = vTex.xyxy * float4(1.0, 1.0, 2.0, 2.0) * Tilling + OceanParams1.yzyz * float4(1.0, 1.0, 2.0, 2.0);

#if %WATER_TESSELLATION_DX11
    DetailTilling = max(2.0, DetailTilling);
#endif
    OUT.baseTC.wz *= DetailTilling;

    OUT.vPosWS = vPos;
    OUT.vPosWS.w = IN.Position.z;

#if %WATER_TESSELLATION_DX11
    OUT.vOceanParams.x = OceanParams1.x;
    OUT.vOceanParams.w = OceanParams0.w;
#endif

    return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// DX11 specifics

HS_CONSTANT_DATA_OUTPUT WaterConstantsHS(InputPatch<v2f, 3> p, uint PatchID : SV_PrimitiveID)
{
#if (D3DX_SDK_VERSION == 43)
    // Workaround for the optimization rule problem of DXSDKJune10's HLSL Compiler (9.29.952.3111)
    // See: http://support.microsoft.com/kb/2448404
    #pragma ruledisable 0x0802405f ;
#endif

    HS_CONSTANT_DATA_OUTPUT OUT = (HS_CONSTANT_DATA_OUTPUT)0;

    // map inputs
    float3 vWP0 = -p[0].vView.xyz + PerView_WorldViewPos.xyz;
    float3 vWP1 = -p[1].vView.xyz + PerView_WorldViewPos.xyz;
    float3 vWP2 = -p[2].vView.xyz + PerView_WorldViewPos.xyz;

    float3 vMiddle = (vWP0 + vWP1 + vWP2) / 3.0f;
    float3 vDir = normalize(PerView_WorldViewPos.xyz - vMiddle);
    float3 vNormal = normalize(cross(vWP2 - vWP0, vWP1 - vWP0));

    // Wave height is stored in vOceanParams.x. The higher the waves, the further the waves may go outside their hull bounds.
    // Waves slosh side to side even more than up and down, so multiplying by 3.5 to make sure we don't cull patches that we shouldn't.
    float cullEpsilon = p[0].vOceanParams.x * 3.5f;
    bool bFrustumCulled = ViewFrustumCull(vWP0, vWP1, vWP2, PerView_FrustumPlaneEquation, cullEpsilon);

    if (bFrustumCulled)
    {
        // Set all tessellation factors to 0 if frustum cull test succeeds
        OUT.Edges[0] = 0.0;
        OUT.Edges[1] = 0.0;
        OUT.Edges[2] = 0.0;
        OUT.Inside   = 0.0;
    }
    else
    {
        // Check edges ws distance - if too big mesh needs to be pre-diced. todo: verify if we can update levels for patches
        float fEdgeDistThreshold = 100.0;
        bool bNeedsPreDicing = distance(vWP0, vWP1) > fEdgeDistThreshold || distance(vWP1, vWP2) > fEdgeDistThreshold || distance(vWP0, vWP2) > fEdgeDistThreshold;

        {
            float4 vEdgeTessellationFactors;

            // Min and max distance should be chosen according to scene quality requirements
            vMiddle = (p[0].vView.xyz + p[1].vView.xyz + p[2].vView.xyz) / 3.0f;

            float fMaxFactor = 16.0;

            float TessellationFactorEdge = 32.0;
            float TessellationFactorInside = 32.0;

            const float fMinDistance = 0.0;
            const float fMaxDistance = 300.0;

            float fTessScale = 1.0;

            float fInside = TessellationFactorInside * fTessScale;
            float fEdge = TessellationFactorEdge * fTessScale;

            // Tessellation level fixed by variable
            vEdgeTessellationFactors = float4(fEdge, fEdge, fEdge, fInside);

            vEdgeTessellationFactors.xyz = distance(vWP2, vWP1);
            vEdgeTessellationFactors.x /= distance((vWP2 + vWP1) * 0.5, PerView_WorldViewPos.xyz);
            vEdgeTessellationFactors.y = distance(vWP2, vWP0);
            vEdgeTessellationFactors.y /= distance((vWP2 + vWP0) * 0.5, PerView_WorldViewPos.xyz);
            vEdgeTessellationFactors.z = distance(vWP0, vWP1);
            vEdgeTessellationFactors.z /= distance((vWP0 + vWP1) * 0.5, PerView_WorldViewPos.xyz);

            float rAvg = max(max(vEdgeTessellationFactors.x, vEdgeTessellationFactors.y),  vEdgeTessellationFactors.z) ;
            vEdgeTessellationFactors.w = saturate(rAvg);
            vEdgeTessellationFactors.xyz *= fEdge;
            vEdgeTessellationFactors.w *= fInside;

            // Assign tessellation levels
            OUT.Edges[0] = clamp(vEdgeTessellationFactors.x, 1.0, fMaxFactor);
            OUT.Edges[1] = clamp(vEdgeTessellationFactors.y, 1.0, fMaxFactor);
            OUT.Edges[2] = clamp(vEdgeTessellationFactors.z, 1.0, fMaxFactor);
            OUT.Inside   = clamp(vEdgeTessellationFactors.w, 1.0, fMaxFactor);
        }
    }

    return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

[domain("tri")]
[partitioning("fractional_odd")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(3)]
[patchconstantfunc("WaterConstantsHS")]
[maxtessfactor(16)]
HS_CONTROL_POINT_OUTPUT WaterHS(InputPatch<v2f, 3> inputPatch, uint uCPID : SV_OutputControlPointID)
{
    HS_CONTROL_POINT_OUTPUT OUT = (HS_CONTROL_POINT_OUTPUT)0;

    // passthrough hull shader
    OUT.baseTC = inputPatch[uCPID].baseTC;
    OUT.screenProj = inputPatch[uCPID].screenProj;
    OUT.envTC = inputPatch[uCPID].envTC;
    OUT.vView = inputPatch[uCPID].vView;
    OUT.GlossinessK = inputPatch[uCPID].GlossinessK;
    OUT.cSpecular = inputPatch[uCPID].cSpecular;
    OUT.vPosWS = inputPatch[uCPID].vPosWS;
    OUT.vOceanParams = inputPatch[uCPID].vOceanParams;

#if %_RT_SAMPLE4
    OUT.ripplesTC = inputPatch[uCPID].ripplesTC;
#endif

  return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

[domain("tri")]
v2f_hs WaterDS(HS_CONSTANT_DATA_OUTPUT IN, float3 BarycentricCoords : SV_DomainLocation, const OutputPatch<HS_CONTROL_POINT_OUTPUT, 3> TriPatch)
{
    v2f_hs OUT = (v2f_hs)0;

    // interpolate attributes
    OUT.baseTC = BarycentricInterp(BarycentricCoords, TriPatch[0].baseTC, TriPatch[1].baseTC, TriPatch[2].baseTC);
    OUT.envTC = BarycentricInterp(BarycentricCoords, TriPatch[0].envTC, TriPatch[1].envTC, TriPatch[2].envTC);
    OUT.vView = BarycentricInterp(BarycentricCoords, TriPatch[0].vView, TriPatch[1].vView, TriPatch[2].vView);
    OUT.GlossinessK = BarycentricInterp(BarycentricCoords, TriPatch[0].GlossinessK, TriPatch[1].GlossinessK, TriPatch[2].GlossinessK);
    OUT.cSpecular = BarycentricInterp(BarycentricCoords, TriPatch[0].cSpecular, TriPatch[1].cSpecular, TriPatch[2].cSpecular);

    OUT.vPosWS = BarycentricInterp(BarycentricCoords, TriPatch[0].vPosWS, TriPatch[1].vPosWS, TriPatch[2].vPosWS);

    float4 vWorldPos = float4(-OUT.vView.xyz + PerView_WorldViewPos.xyz, 1.0);

    float fCamDist = length(vWorldPos.xyz - PerView_WorldViewPos.xyz);

    // Attenuate waves very near (less than 2 meters) to the camera
    float fDisplaceAtten = saturate(fCamDist * 0.5);
    fDisplaceAtten *= fDisplaceAtten;

    // Attenuate the waves between 400-500 meters away(near the edge of the ocean grid) so that triangles that are stretched to the horizon are not displaced.
    const float gridSize = 500.0f; // Todo: Once the size of the tessellated grid is configurable, this number should be based off of that.
    const float lerpDistance = 100.0f;
    fDisplaceAtten *= 1.0f - saturate((fCamDist - (gridSize - lerpDistance)) * (1.0f / lerpDistance));

    float4 vtxDispl = 0.0;

    float2 tcFFT = (vWorldPos.xy) * 0.0125 * TriPatch[0].vOceanParams.w;
    vtxDispl = GetTexture2DLod(WaterDisplMapSampler, float4(tcFFT, 0.0, 0.0));
    vtxDispl += GetTexture2DLod(WaterDisplMapSampler, float4(tcFFT * 2.0, 0.0, 0.0)) * float4(1.5, 1.5, 1.0, 1.0);
    vtxDispl *= fDisplaceAtten;
    vWorldPos.xyz += vtxDispl * 0.06 * TriPatch[0].vOceanParams.x  ;

    float4 vtxDispl2 = GetTexture2DLod(WaterDisplMapSampler, float4(tcFFT + float2(1.0/64, 0.0), 0.0, 0.0));
    vtxDispl2 += GetTexture2DLod(WaterDisplMapSampler, float4(tcFFT * 2 + float2(1.0/64, 0.0), 0.0, 0.0)) * float4(1.5, 1.5, 1.0, 1.0);
    vtxDispl2 *= fDisplaceAtten;

    float4 edgeLen = (vtxDispl2 - vtxDispl);
    vWorldPos.w = saturate(-(edgeLen.x + edgeLen.y) * 0.035);

    float3 vVtxN = ExpandWaterNormals(GetTexture2DLod(WaterNormalsSampler, float4(tcFFT, 0.0, 0.0))).xyz;
    vVtxN += ExpandWaterNormals(GetTexture2DLod(WaterNormalsSampler, float4(tcFFT * 2.0, 0.0, 0.0))).xyz;

    OUT.vVertexNormal.xyz = lerp(vVtxN, float3(0.0, 0.0, 1.0), saturate(OUT.vPosWS.w * 2.0));
    vWorldPos.w = lerp(vWorldPos.w, 0.0, saturate(OUT.vPosWS.w * 1.5));
    vtxDispl = 0.0;

#if %_RT_SAMPLE4
    OUT.ripplesTC = GetWaterRipplesUvs(vWorldPos);
    float fRipplesDisp = 0.5 * GetTexture2DLod(WaterDynRipplesSampler, float4(OUT.ripplesTC.xy, 0.0, 0.0)).z;
    vtxDispl -= fRipplesDisp * OUT.ripplesTC.w;
#endif

    vWorldPos.z += vtxDispl.z;

    OUT.vPosWS = vWorldPos;

    // Transform world position with viewprojection matrix
    float4 HPosition = mul(PerView_ViewProjMatr, float4(vWorldPos.xyz, 1.0));
    OUT.Position = HPosition;

    OUT.screenProj = HPosToScreenTC(HPosition);
    // Output refraction depth scale
    OUT.screenProj.z = saturate(1.0 - 0.15 * sqrt(saturate(OUT.screenProj.w)));

    return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

half3 BumpGen(in v2f_hs IN, float2 vParalaxOffset)
{
    half3 bumpNormal = 0.0;

    // hi frequency
    bumpNormal.xy = ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, IN.baseTC.wz + vParalaxOffset.xy)).xy * DetailNormalsScale;

    // low frequency
    float4 tcBase = IN.baseTC.xyxy * float4(0.25, 0.25, 1.0, 1.0) + vParalaxOffset.xyxy;

#if !%_RT_QUALITY && %_RT_QUALITY1 || %WATER_TESSELLATION_DX11
    bumpNormal    += ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBase.xy)).xyz + ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBase.zw)).xyz;
    bumpNormal.xy *= NormalsScale * 0.5;
#else
    bumpNormal    += ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBase.xy)).xyz + ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBase.zw)).xyz;
    bumpNormal.xy *= NormalsScale;
#endif

#if %_RT_SAMPLE4
    // dynamic ripples
    half2 cRipples = EXPAND(GetTexture2D(WaterDynRipplesSampler, IN.ripplesTC.xy).xy);
    bumpNormal.xy += cRipples * IN.ripplesTC.w;
#endif

#if %WATER_TESSELLATION_DX11
    bumpNormal.xyz = normalize(IN.vVertexNormal.xyz) * float3(2.0, 2.0, 1.0) + float3(bumpNormal.xy, 0.0);
#else
    #if !%_RT_QUALITY && %_RT_QUALITY1
        bumpNormal.xyz += IN.vVertexNormal.xyz;
    #endif
#endif

#if %_RT_OCEAN_PARTICLE
    // Fetch rain sample - todo, remove funky 300/tiling after shipping...
    bumpNormal.xy += GetNormalMap(RainRipplesSampler, IN.baseTC.xy * RainTilling * (300.0h / Tilling)).xy * 5.0h;
#endif

    return normalize(bumpNormal);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

float2 GetParalaxOffset(in v2f_hs IN, half3 vView)
{
    float4 tcBaseVectorized = IN.baseTC.xyxy * float4(0.25, 0.25, 1.0, 1.0) ;

    const half lGradientScale = 0.5 * GradientScale;
    const half lHeightScale   = 0.5 * HeightScale;

    // Compute the height at this location
    half4 height = ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBaseVectorized.xy));
    height.xy = lGradientScale * height.xy;
    height.w  = lHeightScale   * height.w;

    // Compute the offset
    float2 vParalax = vView.xy * height.w + height.xy;

    // Compute the height at this location
    height = ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBaseVectorized.zw + vParalax));
    height.xy = lGradientScale * height.xy;
    height.w  = lHeightScale   * height.w;

    // Compute the offset
    vParalax += vView.xy * height.w + height.xy;

#if %_RT_SAMPLE4
    // Finally add water ripples to paralax offset
    half fSimSize = WATER_RIPPLES_SIM_GRID_SIZE;
    half4 cRipples = EXPAND(GetTexture2D(WaterDynRipplesSampler, IN.ripplesTC.xy + vParalax / fSimSize));

    cRipples.xy = lGradientScale * cRipples.xy;
    cRipples.z  = lHeightScale   * cRipples.z;
    cRipples *= IN.ripplesTC.w;

    vParalax += 4.0 * vView.xy * cRipples.z + cRipples.xy;
#endif

    return vParalax;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void SunSpecular(in v2f_hs IN, half fNdotL, half3 vNormal, half3 vView, inout half3 cSpecularAcc)
{
    half3 R = reflect(-vView, vNormal);
    half LdotR = saturate(dot(PerFrame_SunDirection, R));

    // 2 spec lobes for ocean
    half fSpec = dot(IN.GlossinessK.zw, half2(pow(LdotR, IN.GlossinessK.x), pow(LdotR, IN.GlossinessK.y)));

    //half3 cLight = PerFrame_SunColor.xyz;;
    half3 cSunSpecular = fNdotL * fSpec * IN.cSpecular; //IN.cSpecular = cLight * PerMaterial_SpecularColor * PerFrame_SunColor.xyz * PerFrame_SunDirection.w;

    // Fake sun shadows: if sun oposing reflected surface normal, its darker - use this as hint for shadows (doens't work 100% but it's better than nothing)
    //    - note: this assumption works only for realtime shadows
    // cSunSpecular *= saturate(dot(cSpecularAcc.xyz, 0.333) * dot(cSpecularAcc.xyz, 0.333)); // squashes sun specular result with low SunColor value

    // Add sun specular term
    cSpecularAcc.xyz += cSunSpecular.xyz;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

pixout WaterPS(v2f_hs IN)
{
    pixout OUT = (pixout) 0;

#if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
    DebugOutput(OUT.Color, IN.baseTC);
    return OUT;
#endif

    half3 vView = normalize(IN.vView.xyz);

    // Generate normal map from 4 normal map layers + paralax
    float2 vParalaxOffset = GetParalaxOffset(IN, vView);
    half3 vNormal = BumpGen(IN, vParalaxOffset);

    // Get fNdotE * sign(vView.z) - we want internal reflections as well -
    half fNdotE = dot(vView.xyz, vNormal) * IN.vView.w;

    // Water edge and foam softness
    float sceneDepth = DecodeSceneDepth(sceneDepthSampler, IN.screenProj);
    half softIntersect = saturate(SoftIntersectionFactor * (sceneDepth - IN.screenProj.w));

    // Get reflection color
    half fGloss = PerMaterial_SpecularColor.w;

    // Quick solution: Reduce gloss in distance (the better solution is computing a Toksvig factor for the wave normal map)
    fGloss *= clamp(1.0 - length(IN.vView.xyz) / 250, 0.5, 1.0);

#if %ENVIRONMENT_MAP
    half3 lerpedNormal = lerp(half3(0.0, 0.0, 1.0), vNormal, ReflectionBumpScale);
    half3 R = reflect(-vView, lerpedNormal);
    half4 cReflCM = GetEnvironmentCMap(envMapSamplerCUBE, R, fGloss);
    half3 cSpecularAcc = DecodeHDRCubemap(cReflCM) * ReflectionScale;
#else
    half2 reflNewst = (IN.envTC.xy/IN.envTC.w) + vNormal.xy * ReflectionBumpScale;
    half3 cSpecularAcc = tex2D(ReflectionSampler, reflNewst);
#endif

    // Get refraction and apply refraction masking

    float2 refrNewst = (IN.screenProj.xy / IN.screenProj.w);

    float fSoftCamIsec = 1.0;

    float2 refrTC = vNormal.xy * RefractionBumpScale * softIntersect * IN.screenProj.z;

    #if %WATER_TESSELLATION_DX11
        float3 depthRefr = float3(
            GetLinearDepthScaled(sceneDepthSampler, ClampScreenTC(refrNewst + refrTC.xy * 1.025)),
            GetLinearDepthScaled(sceneDepthSampler, ClampScreenTC(refrNewst + refrTC.xy)),
            GetLinearDepthScaled(sceneDepthSampler, ClampScreenTC(refrNewst + refrTC.xy * 0.985))
        );
    #else
        float3 depthRefr = float3(GetLinearDepthScaled(sceneDepthSampler, ClampScreenTC(refrNewst + refrTC.xy)).xxx);
    #endif

    // Apply refraction mask to bump offsets
    half3 fRefractionMask = (IN.screenProj.www <depthRefr.xyz);

    #if %WATER_TESSELLATION_DX11
        half3 refractColor = DecodeHDRBuffer(tex2D(RefractionSampler, ClampScreenTC(refrNewst + refrTC * fRefractionMask.x * 1.025))).xyz;
        refractColor.y = DecodeHDRBuffer(tex2D(RefractionSampler, ClampScreenTC(refrNewst + refrTC * fRefractionMask.y))).y;
        refractColor.z = DecodeHDRBuffer(tex2D(RefractionSampler, ClampScreenTC(refrNewst + refrTC * fRefractionMask.z * 0.985))).z;
    #else
        half3 refractColor = DecodeHDRBuffer(tex2D(RefractionSampler, ClampScreenTC(refrNewst + refrTC * fRefractionMask.x))).xyz;
    #endif

#if %_RT_FOG && %_RT_VOLUMETRIC_FOG
    half3 fogColor = 0.0;
    float len = length(IN.vView.xyz);
    VolumetricFogTexcoord vtc = GetVolumetricFogTexcoordParamByScreenProj(IN.screenProj, false, len);
    float4 vf = GetVolumetricFogValueJittered(vtc).xyzw;
    half4 globalFogColor = GetVolumetricFogAnalyticalColor(-IN.vView.xyz, len);
    ApplyVolumetricFog(vf, globalFogColor, vtc, fogColor.xyz);

    // subtract fog color from refract color.
    refractColor -= fogColor;
#endif

    // Compute ocean fog
    // We don't want refraction of fragments behind the objects, just fragments underwater between camera and objects (fRefractionMask).
    // instead of "if ((IN.screenProj.w - depthRefr.y) < 0)" use lerp -> 2 instr less.
    // sceneDepth  = non refracted/distorted.
    // depthRefr.y = refracted/distorted depth. Could use a different refraction depth per channel.
    // fRefractionMask.y = refracted/distorted depth. Could use a different refraction mask per channel.
    // We could compute each refract color channel separately but it would cost more and does not make any significant visual difference.
    
    half fFogDepth = lerp(sceneDepth, depthRefr.y, fRefractionMask.y);
    
    half volumeDepth = max(fFogDepth  - dot(IN.vView.xyz, PerView_ViewBasisZ.xyz), 0.0);
    half waterVolumeFog = exp2(-cFogColorDensity.w * volumeDepth / dot(vView.xyz, PerView_ViewBasisZ.xyz));
    
    refractColor = lerp(cFogColorDensity.xyz, refractColor, saturate(waterVolumeFog));
   

    // Get sun specular
    half fNdotL = (dot(vNormal.xyz, PerFrame_SunDirection.xyz));
#if %SUN_SHINE
    SunSpecular(IN, saturate(fNdotL), vNormal, vView, cSpecularAcc);
#endif

    // Final compose refraction/reflection/specular based on fresnel - add foam and blend fog

    const half WaterSpec0 = 0.02;
    half fFresnel = GetEnvmapFresnel(WaterSpec0, FresnelGloss, saturate(fNdotE)).x;

    // Set world soft intersection * camera soft intersection (looks nice but disabled, since costs 0.2 ms)
    half fCameraSoftIsec = saturate((IN.screenProj.w - 0.33));
    half fA = softIntersect;
    fA *= fCameraSoftIsec;

    half fSunShadow = 1.0;

    // Fake sun shadows: if sun oposing reflected surface normal, its darker - use this as hint for shadows (doens't work 100% but it's better than nothing)
    //    - note: this assumption works only for realtime shadows
    fSunShadow *= saturate(0.5 + dot(cSpecularAcc.xyz, 0.333) * dot(cSpecularAcc.xyz, 0.333));

#if %WATER_TESSELLATION_DX11
    // Simple subsurface scattering approximation
    const half3 surfaceSSSColor = PerMaterial_DiffuseColor.xyz * SubSurfaceScatteringScale;

    float waveHeightFactor = IN.vPosWS.w * 0.5 + saturate(fNdotE) * (1.0 - saturate(vNormal.z));
#if %ENVIRONMENT_MAP
    refractColor += surfaceSSSColor * GetEnvironmentCMap(envMapSamplerCUBE, -vView.xyz, clamp(waveHeightFactor, 0.2, 0.7)) * waveHeightFactor * fA;
#endif
    half EdotL = saturate((1.0f + dot(-PerFrame_SunDirection.xyz, vView)) * 0.5);
    EdotL = EdotL * EdotL * EdotL;
    refractColor += surfaceSSSColor * EdotL * (cFogColorDensity * PerFrame_SunColor) * waveHeightFactor * fA;
#endif

    half3 cFinal = lerp(refractColor, cSpecularAcc, fFresnel * fA);

#if %FOAM
    // Attempt to make something look like foam...

    half4 cGlossMap = GetTexture2D(WaterGlossMapSampler, IN.baseTC.xy * 0.05);
    cGlossMap = cGlossMap * 0.7 + 0.3;
    half4 cFoamThreshold = cGlossMap * 2.0 - 1.0; // reuse gloss for masking edges

    #if %WATER_TESSELLATION_DX11
        // approximate foam coesion and sparking through mipmap bias
        half fFoam = tex2Dbias(FoamSampler, float4(IN.baseTC.xy * FoamTilling + vNormal.xy * 0.1, 0.0, -(1.0 - 4.0 * IN.vPosWS.w))).x;
    #else
        half fFoam = tex2D(FoamSampler, IN.baseTC.xy * FoamTilling + vNormal.xy * 0.1).x;
    #endif

    half fFoamOrig = fFoam;

    half fFoamSoftIntersect = saturate(FoamSoftIntersectionFactor * (sceneDepth - IN.screenProj.w)); // -0.25 => to avoid foam on first person arms, looks ugly

    // Blend out edges in interesting way
    fFoam = fFoam * saturate(-fFoamSoftIntersect * (1.0 + cFoamThreshold.x) + fFoam);
    fFoam = fFoam * saturate(fFoamSoftIntersect - fFoamSoftIntersect * fFoamSoftIntersect);

    #if %WATER_TESSELLATION_DX11
        fFoam += (saturate(fFoamOrig * IN.vPosWS.w * fFoamOrig * IN.vPosWS.w) * 0.5 + smoothstep(0.2, 1.0, saturate(fFoamOrig * IN.vPosWS.w)) * 2.0) * FoamCrestAmount;
    #endif

    fFoam *= (PerFrame_SunColor.xyz * saturate(fNdotL) * fSunShadow) * saturate(FoamAmount);
    fFoam *= fCameraSoftIsec;

    cFinal += fFoam;

#endif // %FOAM

#if %_RT_FOG
    #if !%_RT_VOLUMETRIC_FOG
        half4 localFogColor = GetVolumetricFogColor(IN.vPosWS.xyz);
        cFinal.xyz = lerp(localFogColor.xyz, cFinal, localFogColor.w);
    #else
        ApplyVolumetricFog(vf, globalFogColor, vtc, cFinal.xyz);
    #endif
#endif

    OUT.Color.xyz = cFinal;

  return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

technique Water
{
    pass p0
    {
        ZEnable = true;
        ZFunc = LEqual;
        CullMode = None;
        ZWriteEnable = false;

        IgnoreMaterialState = true;

        VertexShader = WaterVS() WaterSurfaceVS;

#if %WATER_TESSELLATION_DX11
        HullShader   = WaterHS() WaterSurfaceHS;
        DomainShader = WaterDS() WaterSurfaceDS;
#endif
        PixelShader = WaterPS() WaterSurfacePS;
    }
}
